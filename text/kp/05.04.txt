5.4 Traps: catching interrupts
If you hit DEL or hang up the phone while watchwho is running, one or
two temporary files are left in /tmp. watchwho should remove the temporary
files before it exits. We need a way to detect when such events happen, and a
way to recover.
When you type DEL, an interrupt signal is sent to all the processes that you
are running on that terminal. Similarly, when you hang up, a hang up signal is
sent. There are other signals as well. Unless a program has taken explicit
action to deal with signals, the signal will terminate it. The shell protucts programs run with & from interrupts but not from hangups.
Chapter 7 discusses signals in detail, but you needn't know much to be able
to handle them in the shell. The shell built-in command trap sets up a
sequence of commands to be executed when a signal occurs:
trap sequence-oj-commands list of signal numbers
The sequence-oj-commands is a single argument, so it must almost always be
quoted. The signal numbers are small integers that identify the signaL For
example, 2 is the signal generated by pressing the DEL key, and 1 is generated
by hanging up the phone. The signal numbers most often useful to shell programmers are listed in Table 5.4.
Table 5,,4: Shell Signal Numbers
o shell exit (for any reason, including end of file)
1 hangup
2 interrupt (DEL key)
3 quit (ctl- \; causes program to produce core dump)
9 kill (cannot be caught or ignored)
15 terminate, default signal generated by kill( 1)
So to clean up the temporary files in watchwho, a trap can should go just
before the loop, to catch hangup, interrupt and terminate:
trap 'rm -f $new $old; exit l' 1 2 15
while :
The command sequence that forms the first argument to trap is like a subroutine call that occurs immediately when the signal happens. When it finishes,
the program that was running will resume where it was unless the signal killed
it. Therefore, the trap command sequence must explicitly invoke exi t, or
the shell program will continue to execute after the interrupt. Also, the command sequence will be read twice: once when the trap is set and once when it
is invoked. Therefore, the command sequence is best protected with single
quotes, so variables are evaluated only when the trap routines are executed.
It makes no difference in this case, but we will see one later in which it
matters. By the way, the -f option tells rm not to ask questions.
trap is sometimes useful interactively, most often to prevent a program
from being killed by the hangup signal generated by a broken phone connection:
$ (trap " 1; long-running-comrnandJ &
2134
$
The null command sequence means "ignore interrupts" in this process and its
children. The parentheses cause the trap and command to be run together in
a background sub-shell; without them, the trap would apply to the login shell
as well as to long-running-command.
The nohup( 1) command is a short shell program to provide this serVIce.
Here is the 7th Edition version, in its entirety:
$ cat 'which nohup'
trap "" 1 15
if test -t 2>&1
then
echo "Sending output to 'nohup.out'"
exec nice -5 $* Â»nohup.out 2>&1
else
exec nice -5 $* 2>&1
fi
$
test -t tests whether the standard output is a terminal, to see if the output
should be saved. The background program is run with nice to give it a lower
priority than interactive programs. (Notice that nohup doesn't set PATH.
Should it?)
The exec is just for efficiency; the command would run just as well
without it. exec is a shell built-in that replaces the process running this shell
by the named program, thereby saving one process - the shell that would normally wait for the program to complete. We could have used exec in several
other places, such as at the end of the enhanced cal program when it invokes
/usr/bin/cal.
By way, the signal 9 is one that can't be caught or ignored: it always kills.
From the shell, it is sent as
$ kill -9 process id ...
ki 11 - 9 is not the default because a process killed that way is given no chance
to put its affairs in order before dying.
Exercise 5-14. The version of nohup above combines the standard error of the command with the standard output. Is this a good design? If not, how would you separate
them cleanly? 0
Exercise 5-15. Look up the times shell built-in, and add a line to your . profile so
that when you log off the shell prints out how much CPU time you have used. 0
Exercise 5-16. Write a program that will find the next available user-id in
/ etc/passwd. If you are enthusiastic (and have permission), make it into a command
that will add a new user to the system. What permissions does it need? How should it
handle interrupts?

