Arithmetic
==========
==========

In This Chapter
---------------
■ Overview
■ Fractions
■ Proportions, Ratios, and Percentages
■ Exponentials
■ Logarithms

Overview
--------
This chapter and the next explore basic mathematics. It is necessary to cover this ground
to prepare for topics presented later in the book. As it is, many people come up against
problems in more advanced settings because they do not understand or have forgotten
basic concepts. Without the basics, it is sometimes possible to find workaround strategies
or use techniques that have been learned by rote, but in the end, understanding how things
work ensures that you will be able to continue indefinitely.
This chapter examines the essentials of arithmetic, working with what in most computer
languages are data types identified as integers and floats. While working with these data
types does not cover the whole of arithmetic, it does provide pointers on a few topics that
are often troublesome.
You can find pseudocode samples relating to this chapter on the book’s companion website.

Fractions
=========
You learned some of the details of working with fractions in the previous chapter, but
because so many people seem to have trouble with them, this chapter presents them in
more detail, starting with some basic arithmetic and moving a few steps beyond.

Calculating Fractions
---------------------
A fraction is something like an instruction: it tells you to divide a by b. Fractions tend to
appear in different ways in print. For example, the fraction
2
is exactly the same as the
5
value 2 ÷ 5. In fact, the division symbol ÷ is a representation of this process: the two dots
represent the numerator (a) and the denominator (b) of the fraction.

Multiply Two Fractions
----------------------
To multiply two fractions, you multiply the numerators and multiply the denominators:
2 3 2 × 3 6
=
× =
5 7 5 × 7 35
Multiplication is represented by the English word “of,” as in “two fifths of three sevenths,”
just as with integers you might say “five of these apples” and mean 5 ¥ apple. It’s easier
to see how it works by breaking the process into two steps: dividing by the denominator
(“take one fifth of three sevenths”) and then multiplying by the numerator (“now you
want two of those”). When multiplying a fraction by an integer, remember that an integer
is a fraction with a denominator of 1, which means that you can multiply the fraction’s
numerator by the integer and leave the denominator alone (multiply it by 1).

Divide Fractions
----------------
To divide by , first flip over so that it becomes . The one is the reciprocal of the
other. Then you multiply:
Why do this? Well, for starters, consider the behavior of integers. When you divide by 2,
you halve the number (which means taking half of the number). As you just observed,
1
this is the same as multiplying by .
2
1
When you divide a number by , you want to find out how many halves go into it (which
2
is twice as many as the number of 1s that go into it). Since the number of 1s that go into
a number is the number itself (anything divided by 1 is unchanged), this means that a
number divided by
1
is multiplied by 2.
2
As a general notion, division is represented by several words in English, such as “per”—
your speed in miles per hour is the number of miles travelled divided by the number of
hours taken—as well as “each” and “a.”

Addition and Subtraction of Fractions
-------------------------------------
Addition and subtraction of fractions is a little more complicated than the previously discussed activities. As long as two fractions have the same denominator, you can add and
subtract them fairly easily. You leave the denominator unchanged and perform normal
arithmetic with the numerators. With addition, + = . With subtraction, − = . In
both cases, you are counting, and the objects with which you are counting happen to be
1
5
units of . It is only when you want to add fractions with different denominators that you
hit problems, and this is so because the units you are trying to add are different.

Fortunately, every fraction can be represented an infinite number of ways, so if you
multiply the numerator and denominator by any number at all, you end up with the same
fraction. This is because any number divided by itself is 1. For example, the fractions

and are both equal to 1. As a result, you can multiply any given number by such

fractions and leave the number unchanged. Calculations can be made easier by choosing
the most convenient representation of them.

Suppose you want to add to . It’s much easier to do this if you recognize that is equal
to (multiplying the top and bottom by 2). Because both fractions have the same denominator, you can use this fact to make the problem into one involving arithmetic among the
values of the denominators: + = . This process even works if you are adding fractions
that can’t be easily converted, such as when is added to .

In this instance, you can “cross-multiply,” which means that you multiply the numerator
and denominator of each fraction by the denominator of the other. In the language of
arithmetic, you “put them over a common denominator” (see Figure 2.1).

Now consider how some of the arithmetic operations can be applied to code. To make things
easier to understand, a pseudocode function can be created. The function encapsulates a
problem involving fractions. Its name is add Fractions() , and it takes two arguments, each
a fraction represented by a two-element array:

A problem with this function is that the calculations it involves are potentially much
more complicated than they need to be. Consider the expression presented earlier,
1 1
4 2
2 1
+ . With the add Fractions() function, you calculate + , instead of the simpler + .
2 4
8 8
4 4
6
3
What’s more, the final answer is given as rather than . While this is technically
8
4
correct, it is not what you really need.

Factors and Factorization
-------------------------
In the previous section, the technique for adding fractions was to change the representation of the fractions to a more complicated representation before adding them. The problem with this approach is that you end up with more complexity than is needed. A better
approach is to switch them back to a simpler version at the end. This is called reducing a
fraction to its lowest terms, and to do this, it’s necessary to look at factors. A factor or
divisor of an integer is an integer that can be exactly divided into the integer. So 1, 2, 3,
and 6 are all factors of 6. If n is a factor of m, then you say that m is a multiple of n (or
more strictly, an exact multiple, or integer multiple).

The number 6 is called a “perfect number,” because it is the sum of all its factors
other than itself. The numbers 1, 2, and 3 are the factors of 6, and 1 + 2 + 3 = 6. The
Pythagoreans were particularly fond of perfect numbers.

Consider the fraction , introduced previously. You can see that it would be much simpler 3/4
if you divided everything by 2, making it . The number 2 is a factor of both the numerator
and the denominator: it is a common factor of 6 and 8. In fact, because 6 and 8 have no
common factor greater than 2, 2 is called the highest common factor, or more often, the
greatest common divisor, or GCD. To reduce a fraction to its lowest terms, you need to
divide the numerator and denominator by their GCD.

In early studies of arithmetic, you probably found GCDs by finding the prime factors of
two or more numbers. There is a simpler method, but for now it is useful to continue considering prime factors. They are useful in their own right. To explain prime factors, it is
first necessary to define prime numbers. A prime number (or just “a prime”) is a number
whose only factors are itself and 1. Conventionally, you exclude the number 1 from the
list of primes because it’s something of a special case and makes for a less redundant
pattern. The list of primes goes 2, 3, 5, 7, 11, 13, 17, 19, . . . . The prime numbers are
something like the building blocks of multiplication, and there is an enormous body of
mathematical writing about them—most of which has been by mathematicians looking
for patterns in their distribution or ways to test whether a number is prime. Such studies
are particularly important in the field of cryptography.

Generating Prime Numbers
------------------------
You can generate a list of prime numbers less than some number M quite easily using a
technique known as Eratosthenes’ Sieve. To do this, start with a list of all the numbers
from 2 to M. Take the first number in the list, and delete all the numbers in the list that
are divisible by this number. Remove the number from the list and add it to your list of
primes. Then repeat this process. You need to do this only until the first number in the list
is greater than M . After you’re past that point, all the remaining numbers must be prime,
since they’re not divisible by any number smaller than the square root, and any product
of two numbers bigger than M must be bigger than M.
To return to the prime factors, a prime factor of a number n is, as you might expect, a
prime number that is a factor of n. Every number can be represented in a unique way as
a product of prime numbers—for example, 12 = 2 ¥ 2 ¥ 3. This fact goes by the very grand
name of the Fundamental Theorem of Arithmetic. A number with more than one prime
factor is said to be composite.

The Fundamental Theorem of Arithmetic is one of the reasons that mathematicians
contend that 1 is not prime. If it were, it would be an exception to this rule of
uniqueness. You could represent any number as a product of its prime factors and
any number of 1s.

To find the prime factors of an arbitrary number n, the only absolutely reliable way is to
keep dividing it by prime numbers until you find one. Of course, this can be a slow process
for large numbers, but it’s not too bad for small ones, especially if you have already generated a list of primes. Here’s a function that will do it.

When people are searching for extremely large primes (as they often do for cryptographic or other purposes), they don’t use this method because it would take an
unfeasibly long time even on a very fast computer. Instead, they generally use various tricks to hone in on numbers that are extremely likely to be prime to within some
particular degree of certainty. Depending on the application, this is usually enough.

GCD and Euclid's Algorithm
--------------------------
To return to the question of the GCD of two numbers, if you want to find gcd(n, m) , you
can do so by finding the prime factors of each of the numbers. Say that n is 24 and m is
60. You use the function previously defined to find that the prime factors of n are 2, 2, 2,
3. Of m the prime factors are 2, 2, 3, 5. Then you just take as many elements of each list
as you can that match, which are two 2s and one 3. So gcd(n, m) is 2 ¥ 2 ¥ 3 = 12.
On the other hand, you could use the phenomenally simple and ingenious method known
as Euclid’s Algorithm, which is approximately a gazillion times faster.
Euclid’s Algorithm relies on a simple observation. If you have three numbers, a, b, c, such
that a = b + c, and if some number d is a factor of both a and b, then it must be a factor
of c as well.
Armed with this knowledge, you can design another function. To find gcd(n, m) , where
n ≥ m, divide n by m and find the remainder r. Then you know that n = a ¥ m + r, for
some a, where r < m (recall that this is the definition of the remainder). If r = 0, then m
is a factor of n, so gcd(n, m) = m. Otherwise, because the GCD is a factor of both n and
m by definition, it must also be a factor of r. And having gone this far, you repeat the
process using the numbers m and r in place of n and m. Here is the pseudocode for the
function:

Eventually, you bottom out with a number d that is an exact divisor of the two arguments,
and you can then work back to find that it is a common divisor of both of the original
numbers. Euclid’s Algorithm is one of the most beautiful things in mathematics!

Lowest Common Multiple
----------------------
After you have gcd(n, m) , you can also find another useful number, the least (or lowest)
common multiple (LCM) of n and m. This is the smallest number that has both n and m
as factors, and it is equal to n * m / gcd(n, m) . The LCM brings us back to the sum of
two fractions.

When adding two fractions, instead of cross-multiplying, the most efficient system is to
“put them over the lowest common denominator.” In other words, you multiply the top
and bottom of each fraction by the smallest possible number so that they have the same
denominator. This lowest common denominator is the LCM of the two denominators.
Consider how this works by calculating
7
7
+ . Instead of a bare cross-multiplication,
24 30
you multiply each fraction, top and bottom, by the denominator of the other, divided by
the GCD of the two denominators. Here is what happens:

Modulo Arithmetic
-----------------
As with several other techniques considered so far, Euclid’s Algorithm relies on a process
of finding the remainder when dividing one number by another. This turns out to be such
a useful procedure that there is a standard term for it. If you have two numbers n and m,
such that when you divide n by m you get a remainder r, it is said that “n is congruent to
r modulo m.” Congruence is normally expressed with a special triple bar symbol (≡), so
you write n ≡ r(mod m).

Actually, the congruence relation is a little more subtle than that, for two numbers are congruent mod m whenever they differ by an integer multiple of m. So when working modulo
5, the numbers 4, 9, 14, . . . are all equivalent because they are all congruent to 4.
Most programming languages allow you to work with modulo congruence relations
through a modulo function. The function takes two arguments, n and m, and returns the
remainder r. The expression is coded along the lines of mod (n, m) = r .

If n ≥ 0, then the mod() function returns a value between 0 and m − 1. If n < 0, it generally returns a value between – (m − 1) and 0 (in the most commonly used languages, at
least). Since in itself it is very useful, you can use a modified modulo function. Here is
the pseudocode for this function:

Cycling Through Data
--------------------
Because it is commonly used in situations where something cycles through a small list of
options, modulo arithmetic is sometimes known as clock arithmetic. A clock contains
only 12 numbers, so when calculating hours, 8 + 6 = 2. This is an example of modulo
arithmetic in action.

In programming, you can use modulo calculations to deal with circumstances like these.
For example, suppose you create a clock and want to be able to add times together. Without
modulo arithmetic, a pseudocode function would look something like this:

Obviously, this isn’t a particularly complicated function. But still, using modulo arithmetic,
it can be substantially simplified:

Since such calculations take some getting used to, it’s helpful to examine them in more
detail. In the first line, the new minutes are worked out. These should be in the range 0–59.
Next, the full number of new minutes ( oldMinutes + addMinutes ) is evaluated, with the
result that their value is modulo 60. The next line works out how many hours were taken
out in the calculation, and for this a trick is employed. Recall that s trictModulo(n, m)
is the remainder when n is divided by m. This means that, for some a, n = a*m +
strictModulo (n, m) . To find a, then, you subtract strictModulo (n, m) from n and
divide by m. In this case, since a is the number of hours (multiples of 60 minutes), you
increase addHours by this amount.

Proportions, Ratios, and Percentages
====================================
Returning to fractions, one of the most powerful interpretations of a fraction is as a ratio
between the numerator and denominator. Another is as a percentage. This section considers these two concepts in detail.

....
⁄.....,,..,....
⁄
1
2...,.
1 + 2
+
=
= 1. In other words,
1 + 2 1 + 2 1 + 2
you divide the cake into two pieces, one 1 3 the size, the other 2 3 the size.
as big as the other. To do this, you use the fact that

Paper
-----
Ratios are most useful when dealing with scales of objects. If a piece of paper is 297 mm
wide and 210 mm high (international standard A4 size), when you scale it to double its
size, its sides remain in the same proportion. This isn’t surprising because, as has already
been shown, multiplying both the numerator and the denominator of a fraction by the
same number leaves the fraction unchanged.
This fact is quite useful when scaling an object. If you know the initial ratio of the height to
the width, then to calculate the height given the width, all you need to do is to multiply the
new width by the same ratio. Here is the pseudocode for a function that accomplishes this:
function new Height(originalWidth, original Height, new Width)
return new Width * original Height / original Width
end function

You can also think about this the other way round. When scaling any object, every linear
measure of the object (its diagonal, height, width, perimeter, and so on) is multiplied by
the same amount. If you know the original value and new value of any one of these, every
other dimension must be multiplied by the proportion of the new value to the old.
Consider, for example

This fact makes it easy to create a mapping function between two rectangles. If you know
the coordinates of a point in one rectangle, you can relate them to the equivalent point in
the other rectangle by multiplying them by the same proportion.
Incidentally, the A classification of paper sizes is chosen specifically so that when you cut
a piece of paper in half horizontally (in portrait format), you get the next A size up (see
Figure 2.2). You can represent this algebraically as
a Height
a Width
=
a Width ( a Height / 2 )
which translates to
a Height 2 = 2 × a Width 2
and
a Height
= 2
a Width

So for each size of paper, the height is 2 = 1.414 . . . times the width (or very close to it):
2
297
= 2.0002 . . . . Figure 2.2 illustrates how the rectangles diminish as the ratio is applied.

The Golden Ratio
----------------
Another useful proportion is called the golden ratio. A highly celebrated phenomenon
among mathematicians, it is represented by the Greek letter Phi: φ (pronounced fee).
This is the proportion of a rectangle such that, if you cut a square sized portion from one
end, the remaining piece is in the same proportions as the original (see Figure 2.3). The
algebra will not be explained in this context, but it turns out that φ =
1 + 5
= 1.618 . . . .
2
As Figure 2.3 illustrates, a pattern similar to the one glimpsed in Figure 2.2 results.

The ancient Greeks and other thinkers through the ages have ascribed all kinds of wonderful properties to φ, calling it the Divine Proportion, the Golden Mean, and so on. They
have contended that objects placed on a canvas (among other things) with such proportions are the most aesthetically pleasing. This is true to an extent (consider the facade of
the Parthenon, which is often flaunted as an example), but recent psychological tests on
the subject have shown that this isn’t universal. The proportion 1:sqrt(2) , as with the
standard paper size, is much closer to the most popular. A further point, however, is that
what people currently prefer could be explained by their continual exposure to A series
paper.

Fibonacci Sequence
------------------
When the Golden Ratio is mentioned, the Fibonacci Sequence is often the next topic. The
Fibonacci Sequence is the sequence of numbers 1, 1, 2, 3, 5, 8, 13, 21, . . . , where each
number is the sum of the two previous numbers. The ratio between successive terms of this
sequence rapidly approaches φ, and this happens with any sequence of numbers generated
by the same rule as the Fibonacci Sequence. The Fibonacci Sequence has proven interesting
in a number of areas of science, for it frequently crops up in nature, describing, for example,
such things as the concavity of seashells or how leaves on a vine are distributed.

Making a Slider
---------------
Another common area where the notion of proportion is used involves sliders. A slider is
a graphical representation of a range of numbers. In the standard slider, a line represents
the range of numbers you are looking at (say from 10 to 100), and a movable pointer represents the current value (see Figure 2.4).

To make a slider, you must know four values: the position of each end of the line and the
maximum and minimum values they represent. For now, it is not necessary to know exactly
what is meant by the “position” of the ends of the line. Just think of it as a number—say
100 for one end and 200 for the other.

When you initialize the slider, you can quickly calculate what might be expressed as its
“intrinsic proportion.” You can think of this as the range of values represented by one unit
of the slider. You calculate the proportion by finding the size of the total range divided by
the total length of the slider.
intrinsic Proportion =
max Value − min Value
end Point 2 − end Point 1

To find the value represented by a particular point on the slider, you find how far the value
is along the slider, multiply it by the intrinsic proportion, and then add on the minimum
value:
Value = ( this Point − end Point 1 ) × intrinsic Proportion + min Value

Notice how similar this is to calculating proportions of a scaled piece of paper. Ultimately,
it’s the same process. You’ve created a virtual piece of paper whose width is the length of
the slider, and whose height is the range of values represented. When a new point is found,
you scale down to another rectangle with the new width, but in the same proportions. It’s
necessary only to remember that your rectangle doesn’t necessarily start at zero, so you
have to add on the minimum value, as well.
You can also go the other way. If you have a particular value you want to represent, you
can find its position on the slider by finding its distance from the minimum value, dividing by the intrinsic proportion, and adding the end point:
new Point =
this Point − min Value
+ end Point1
intrinsic Proportion

Scrollbars are a special kind of slider. They represent the position of a small image within
a large one. The principle is the same as with the standard slider, but it is complicated by
the fact that the small image may vary in size. For example, consider a scrolling piece of
text. If you know the height of the text in pixels and the height of your scrolling window,
then your scrollbar is a slider that represents the values between 0 (the topmost position)
and text Height window Height (the bottom most position). These values represent the pixel
location of the text at the top of your window. When the text is at position text Height
window Height, then the bottom of the window, window Height pixels away, is at text Height,
the bottom of the text.
If you look at the scrollbars in standard windows, you see that they also resize the sliding
marker within the bar, to represent how much of the image you can see. This proportion is
given by window Height / text Height (see Exercise 2.1).

Calculating Percentages
-----------------------
Percentages are yet another kind of fraction. The number 20% is nothing more or less than
the fraction
20
. (The word “percent” means “per cent,” or “per hundred.”) Calculating
100
with percentages is therefore a fairly straightforward extension of calculating with fractions, with the help of your English to math translation skills.
1. 20% of 1000 is the same as 20/100 multiplied by 1000, which is 200.
2. 20% of 1000 is 1000 – 20% of 1000, which is 1000 – 200 = 800.
3. 20% more than 1000 is 1000 + 20% of 1000, which is 1000 + 200 = 1200.
These last two calculations can be simplified slightly by adding or subtracting the percentage from 100 first:
1. 20% off 1000 is 80% of 1000.
2. 20% more than 1000 is 120% of 1000.
Going the other way is just as simple. If an item is knocked down from $25 to $20, you
can calculate the percentage decrease. The item has dropped by $5, which is
original value. Since
5
¥ 100 = 20, this is a decrease of 20%.

Compound Interest
-----------------
Percentages only become complicated in the world of compound interest, such as when
money is added to an account by a fixed percentage each year. If you have a bank account
that pays 3% interest, and you put in $1000, how much will you have at the end of 10
years? You might think that it’s just a matter of adding 3% of $1000, which is $30, each
year, but of course at the end of the second year you no longer have $1000. Instead, you
have $1030. As a result, the percentage is wrong. To arrive at the right percentage, you
must count the increase cumulatively.
Here is the output from the code in the mortgates.html file, which generates a 10-year
schedule.

Debts and Interest
------------------
Interest on debts is similar, although loans such as mortgages are complicated further by
the fact that you are paying off the debt as you go along. You may have seen the “mortgage calculators” you can use to enter the amount of mortgage, interest rate, and years of
payment. Since this is probably the most complicated type of percentage calculation, it’s
worth extended consideration. (Incidentally, what is being described here is a particular
kind of capital and repayment mortgage: the precise nature of mortgages varies from
country to country and lender to lender.)
Consider first paying a monthly amount of $1000 on a mortgage of $100000, at an interest rate of 5%. How long would it take to pay off the mortgage?
To start with, you must convert the interest rate into a monthly form. To accomplish this,
make it a fraction so you don’t have to worry about percentages. From this beginning, the
annual interest rate is
5
, or 0.05. You divide this by 12 to get the monthly interest rate
100
of 0.00417. Note that this already means that the true interest rate over the year is in fact
more than 5%, because this is compound interest. The annual interest is 1.00417 12 – 1 =
0.0511, or 5.11%.

At the end of each month, the debt is increased by 0.00417. In other words, it is multiplied
by 1.00417. After one month, this amounts to $100417. Then your payment is taken off
the debt, so the current value of the loan is now $99417. Each month, you calculate
new Loan = old Loan ¥ 1.00417 – $1000.
Using this equation, here are the results

This mortgage took just over 10 years to pay off—and you paid back significantly more
than your original loan. Your total payment was $129628.96, nearly 30% more.
You can write this as another formula, although the algebra is a lot more complicated:
(
)
debt After N Months = initial Amount × I n − monthly Payment × I n − 1 + I n − 2 + ... + I + 1
where I is the monthly increase, given by
1 +
The sequence I
n − 1
annual Interest
1200
+ I n − 2 + ... + I + 1 is a special case of what is called a geometric progression, and turns out to have a value of
I n – 1
, so the final formula is
I – 1
debt After N Months = initial Amount × I n − monthly Payment ×
I n − 1
I − 1
As though using a normal mortgage calculator, suppose that you want to calculate what your
monthly payment will need to be if you are to pay off the debt in a particular number of
years, assuming a fixed interest rate. If you are setting the amount of debt to 0 in the previous formula, set n to the correct number of months, and invert the formula, the result is
as follows:
monthly Payment = initial Amount ×
I − 1
I n − 1
where n = number Of Years ¥ 12.
Plug in the values of $100,000 at 5% over 10 years, and you get a monthly payment of
$1060.66, which is just what the online calculators will tell you.


Exponentials
-------------
You have already used the power function several times, and speaking generally, this
function represents “multiplying a number by itself n times.” While this description marks
a good beginning, full understanding of the power function requires delving further into
what can be done with the function.

Calculating with Powers
------------------------
What does it mean to multiply a number by itself –0.3 times? It seems to make no sense,
but if you try entering power(2, -0.3), the computer will spit the value 0.81 back at you
without hesitation. The idea of negative and fractional powers follows from the original
definition. To see how this is so, consider some basic questions:
■
What is n p+q ?
This means multiply n by itself (p + q) times. This is the same as multiplying it
by itself p times and then multiplying the result by it q times. So n p+q = n p ¥ n q .
■
What is n p¥q ?
This means multiply n by itself p ¥ q times. It is the same as multiplying it by
itself p times, and doing that q times, which means n p¥q = (n p ) q = (n q ) p .
■
What is n 0 ?
By the addition formula, for any p, n 0+p must be equal to n 0 ¥ n p . But n 0+p = n p ,
so for any n, n 0 = 1.
■
What is (n ¥ m) p ?
This means multiply (n ¥ m) by itself p times. This is the same as multiplying n
by itself p times, multiplying m by itself p times, and then multiplying the results.
So (n ¥ m) p = n p ¥ m p .
■
What is (n m ) p ?
This appeared the other way round in the first example. Just to confirm, this
means multiply n m by itself p times, n m ¥ n m ¥ ... ¥ n m . By the first addition
formula, this is equal to n m¥p .
■
What is n –p ?
By the addition formula, you know that n p–p = n p ¥ n –p . But n p–p = n 0 = 1, so this
means that n –p =
■
1
.
n p
What is n 1 / p ?
Take a look at (n 1 / p ) p . This is equal to n 1 , which is equal to n 1 , which is n.
Therefore n 1/p is the number such that when taken to the pth power, it is equal to
n, otherwise known as the pth root of n. As a result, the square root, or second
root, of n is equal to n 1/2 .


As the previous list shows, the special definitions for negative or fractional powers follow
naturally from just trying to make them consistent with the definition for integer powers.
In fact, you can define a power function for all kinds of things, including imaginary numbers, matrices, and even functions themselves.
One warning is appropriate, however. Within the realm of real numbers, fractional powers
of negative numbers tend to be a problem. Consider, for example, that there is no square
root of –1. On the other hand, there is a cube root (which is also –1!). In general, computers and calculators tend to avoid difficulties by not letting you even try to take the
square root of –1. If you were to try to take power ( –1.1/3.0) , a problem that does not
have an answer, it won’t let you. Given that the computer has no native way to represent
the exact fraction 1 3 , this makes sense. If you need to find the cube root (or any other
root) of a negative number, find the root of its absolute value and check it. Here is a
pseudocode approach to accomplishing this:
⁄
function mthRoot(n, m)
if n<0 then
set p to power(-n, 1.0/m)
if abs(power(-p, m)-n)<0.1 then return –p
otherwise return “No such value”
otherwise
return power(n,1.0/m)
end if
end function
To account for likely rounding errors, this function uses the trick of checking for close-
ness rather than equality of floats.

The Number e and the exp( ) Function
------------------------------------
Another word for power is exponential, a term already encountered. This word is used to
describe the behavior of powers in general, rather than any particular power. For example,
you speak of an “exponential function,” or a value “growing exponentially.” When working with exponentials, you’re likely to come across the number e, which is approximately
2.718. This number has a special property that will be dealt with at length in a later
chapter, but for now just think of it as a number. It happens to be equal to the infinite sum
1 1 1 1
+ + + + ... , as well as a lot of other rather pretty patterns. (The exclamation points
0 ! 1 ! 2 ! 3 !
indicate the factorial function n! = 1 ¥ 2 ¥ ... ¥ n, with 0! defined to be 1.)

From a programmer’s point of view, the number e is most likely to be encountered in the
exp() function, where exp(x) equals e x . [To get the number e itself, just enter exp(1). ]
It’s a kind of “standard” for exponentials.
Note
Don’t confuse the number e with the “exponential” notation you saw in Chapter 1,
such as 1.53 e6. There “e” is just a label that tells us how many decimal places to
shift. Mathematically, it’s equivalent to multiplying the mantissa by a power of the
current base—in this case, assuming you are in decimal, it is 1.53 ¥ 10 6 .


Exponential Functions in Real Life and Physics
----------------------------------------------
Mary has a Russian Vine in her back garden, which increases in length by 20% every
week. This week it is 1 m long. If it keeps growing at the same rate, how long will it be
in a year’s time?

You may recognize this problem as similar to the mortgage calculations reviewed earlier
in the chapter. As became evident with those problems, any time that a value is multiplied
by a constant increment over time, it rapidly changes. This is called exponential growth,
and it’s commonly encountered in real-world problems concerning growth of populations, organisms, or economies.

After one week, Mary’s vine is 1.2 m long. After two weeks, it is 1.2 ¥ 1.2 = 1.44 m long.
After 52 weeks, it will be 1.252 = 13104.63 m long—over 13 km! This explains the reason for the term “population explosion.” Exponential growth is very fast, and even the
smallest growth rate can add up to a lot. If it only increased by 5% every week, it would
still reach over 12 m in a year.
When something is not growing but shrinking by a constant factor, you have exponential
decay. This is most familiar from the area of radioactivity, where a radioactive element
has a so-called “half-life,” which is the length of time it takes for half of any particular
sample to decay. As exponential growth is fast, however, exponential decay is slow. In
fact, in a sense, it is infinitely slow, because it will never finish altogether. If you keep
multiplying a number by 1 2 , it becomes smaller and smaller, but it will never reach zero.
Still, it will get as close to it as you like, and it is said, mathematically, to tend to (or
approach) a limit of 0.

People often become confused about radioactive decay. When they speak of a radioactive
element having a half-life of several hundred (or thousand) years, they forget that this
means it is not very radioactive. It is decaying slowly. And the element still will not be
very radioactive a long time from now. Conversely, elements that are highly radioactive
have a short half-life, so that while they are harmful in the short term, they soon decay
and become relatively harmless. The most dangerous elements are those with intermediate half-lives, such as strontium-90, with a half-life around 30 years.


Logarithms
----------
The flip side of the exponential function is the logarithm, a useful tool for dealing with
very large numbers.

Calculating with Logarithms
---------------------------
A logarithm is the inverse of an exponential. If a = b c , then you say c = log b (a). This is
pronounced as, “the logarithm to base b of a,” or “log to base b of a.” It is the power you
have to raise b to in order to get the answer a.
Logarithms are generally available on the computer as one or more of the functions log e ( )
and are sometimes referred to simply as log() . Usually log e ( ) is also expressed as ln(),
which is pronounced “natural logarithm.”
Most calculations with logarithms are direct counter parts of calculations with powers:
■
log(a) + log(b) = log(a ¥ b) [to any base]
If n p = a and n q = b, then n p+q = n p ¥ n q = a ¥ b. So log(a ¥ b) = p + q, and since
log(a) = p and log(b) = q, you have log(a) + log(b) = log(a ¥ b).
■
k ¥ log(a) = log(a k ) [to any base]
This follows fairly naturally from the previous result, but you can also derive it
directly. For instance, suppose n p = a. Then a k = (n p ) k = n p¥k . So log(a k ) = p ¥ k,
and since p = log(a), this means that k ¥ log(a) = log(a k ).
■
log a (a) = l
This is a consequence of the definition of a logarithm and th


Using Logarithms to Simplify Calculations
Before the arrival of pocket calculators and computers, logarithms were one of the most
important tools used by mathematicians, scientists, and engineers. As Figure 2.5 illustrates,
the fundamental tool was the slide rule, which showed two sets of numbers drawn in a
logarithmic scale.

What exactly is a logarithmic scale? If you look at Figure 2.5, you can see that the numbers
are not spread evenly. They are bunched up at one end and more spread apart at the other.
It is called a logarithmic scale because, if you take the value at each point on the ruler and
replace it with its own logarithm to some base, the resulting ruler is linear. Equivalently, a
point n centimeters along the rule represents the value p n , for some base p that depends on
the scale.

If you measure the distance on the scale between, say, 1 and 10, it is the same as the
distance between 10 and 100. In fact, this is the primary feature of a logarithmic scale. If
a = q ¥ b and c = q ¥ d for some q, then the distance between a and b on the scale is the
same as the distance between c and d. Compare this to the normal linear scale, which has
the same property for addition instead of multiplication. If a = q + b and c = q + d, then
the distance between a and b is the same as the distance between c and d. Basically, a
slide rule is to multiplication what a ruler is to addition.
This property is useful because it means that you can easily multiply two numbers together
using the slide rule. For example, as shown in Figure 2.6, if you want to multiply 12.45 by
37.6, you find the point 12.45 on the top scale and slide the lower scale so that the inner
1 is matched to it.


Next, you locate the position of 37.6 on the lower scale and find the point that corresponds
to it on the upper one. This point is marked in Figure 2.6. It is 468.12, the correct product.
This works because the distance between 1 and 37.6 on one scale is equal to the distance
between 1 ¥ 12.45 and 37.6 ¥ 12.45 on the other. Can you see how this follows from the
definition of the logarithm? (See Exercise 2.3.)


Using Logarithms to Deal with Large Numbers
-------------------------------------------
While slide rules are no longer standard issue in classrooms, the principle behind them
remains important. This principle is that logarithms are a handy tool for dealing with large
numbers. By applying a logarithm, you can bring enormously large numbers down to a
more negotiable scale. As an illustration, consider that on a linear scale the value 5,000,000
is a thousand times greater than 5000. When working in the logarithmic base of 10, it is only
three units greater.
This way of thinking is intuitively obvious. You have already used it when describing
numbers in scientific notation. With the numbers just mentioned, 5,000,000 is represented
in base 10 as 5 e6 and 5000 as 5 e3. In fact, the word “base” for both the logarithmic scale
and the base notation looked at in Chapter 1 is a marker for how similar the two concepts
are. As with the slide rule, it is a natural way of thinking when dealing with a multiplicative world instead of an additive one.

Note
----
As will be seen in a later chapter, our ears do this, too. Both volume and pitch are
interpreted by our brains using a logarithmic scale. The C below middle C has a frequency half that of middle C, and the C above that has twice the frequency again.
Still, you hear them as being the same “distance” apart.

Logarithms are useful for dealing with problems involving powers. Looking back at Mary’s
Russian Vine, if you recall, grows by 20% each week (each week its length is multiplied by
1.2), it’s reasonable to ask how many weeks it will be before the vine is long enough to
encircle the world. The Earth has a circumference of approximately 40,000 km, which
means that you want to know how many times you have to multiply 1 m by 1.2 to get an
answer of 40,000,000 m.

Note
The circumference of the Earth has been known (approximately) since the time of
the Greeks. It was first calculated accurately by Eratosthenes, creator of the Sieve
glimpsed earlier in this chapter.

You Should Now Know
■ How to make calculations with fractions, ratios and percentages
■ The concept of an interest rate and how it can be calculated
■ The workings of the mod() function and how to use it to calculate with loops
and integer divisions
■ The concepts of factor, prime number, GCD and LCM, and how to use Euclid’s
Algorithm to calculate the GDC of two integers
■ The meanings of proportion and ratio, and how to use them to map between
values and sizes, as well as create a graphical representation of a range
■ How to use exponentials and logarithms to deal with large numbers and
multiplicative functions

